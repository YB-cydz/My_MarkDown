# 斜雷达的思路(重力对齐)

> 参考[倒装mid360雷达进行重力对齐](https://blog.csdn.net/weixin_65546874/article/details/152808848?ops_request_misc=elastic_search_misc&request_id=a793471a6f4466f278dda6b9a318e21b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-152808848-null-null.142^v102^pc_search_result_base2&utm_term=mid360倒置安装&spm=1018.2226.3001.4187)

在`FAST_LIO/src/IMU_Processing.hpp`中，将192、193行的

```c++
state_ikfom init_state = kf_state.get_x();
init_state.grav = S2(-mean_acc / mean_acc.norm() * G_m_s2);
```

改为

```c++
  // 让IMU测到的重力方向和世界坐标系的Z轴对齐
  // mean_acc是IMU静止时测到的加速度，实际上就是重力加速度的方向。
  // 比如正装IMU，mean_acc大约是[0, 0, 9.8]；倒装IMU大约是[0, 0, -9.8]
  /* modified by SanghyunPark - Start */
  // 计算一个旋转，把mean_acc转到世界Z轴
  Eigen::Quaterniond rotation = Eigen::Quaterniond::FromTwoVectors(mean_acc, Eigen::Vector3d::UnitZ());
  // 用这个旋转把IMU的坐标系转正
  mean_acc = rotation * mean_acc;
  mean_gyr = rotation * mean_gyr;
  state_ikfom init_state = kf_state.get_x();
  // 把这个旋转结果作为IMU的初始姿态
  init_state.rot = rotation;
  // 设置重力向量
  init_state.grav = S2(-mean_acc / mean_acc.norm() * G_m_s2);
```

---

# 将原本川大方案的倒置改回正置

总共需要修改两个地方

### 第一处

在于`cmd_chassis/src/rot_imu.cpp`(**省流：在回调函数中将对接收到的imu的`msg`的数据处理部分全部删除，只保留发布`msg`**)

将下面的代码

```c++
class IMURotateNode : public rclcpp::Node
{
public:
    IMURotateNode() : Node("imu_rotate_node", rclcpp::NodeOptions().use_intra_process_comms(true))
    {
        publisher_ = this->create_publisher<sensor_msgs::msg::Imu>("imu/data", 10);
        subscription_ = this->create_subscription<sensor_msgs::msg::Imu>(
            "livox/imu", 10, std::bind(&IMURotateNode::listener_callback, this, std::placeholders::_1));
    }

private:
    void listener_callback(const sensor_msgs::msg::Imu::UniquePtr msg)
    {
        // Create a quaternion for the rotation
        tf2::Quaternion rotation_quaternion;
        rotation_quaternion.setRPY(3.14159, 0, 0);  // 180 degrees in radians

        // Rotate the orientation of the IMU data
        msg->orientation.x = 0.0;
        msg->orientation.y = 0.0;
        msg->orientation.z = 0.0;
        msg->orientation.w = 1.0;

        msg->angular_velocity.z = -msg->angular_velocity.z;

        msg->linear_acceleration.y = -msg->linear_acceleration.y;
        msg->linear_acceleration.z = -msg->linear_acceleration.z;

        // Publish the rotated IMU data
        publisher_->publish(*msg);
    }

    rclcpp::Publisher<sensor_msgs::msg::Imu>::SharedPtr publisher_;
    rclcpp::Subscription<sensor_msgs::msg::Imu>::SharedPtr subscription_;
};
```

修改为
```c++
class IMURotateNode : public rclcpp::Node
{
public:
    IMURotateNode() : Node("imu_rotate_node", rclcpp::NodeOptions().use_intra_process_comms(true))
    {
        publisher_ = this->create_publisher<sensor_msgs::msg::Imu>("imu/data", 10);
        subscription_ = this->create_subscription<sensor_msgs::msg::Imu>(
            "livox/imu", 10, std::bind(&IMURotateNode::listener_callback, this, std::placeholders::_1));
    }

private:
    void listener_callback(const sensor_msgs::msg::Imu::UniquePtr msg)
    {
        publisher_->publish(*msg);
    }

    rclcpp::Publisher<sensor_msgs::msg::Imu>::SharedPtr publisher_;
    rclcpp::Subscription<sensor_msgs::msg::Imu>::SharedPtr subscription_;
};
```

### 第二处

> 一开始的思路是尝试直接将官方包替代川大的，后来发现川大的相较于官方的已经做出了相当大的修改，因此最终选择修改参数的方法

川大代码中`sentry_bringup`包中`mapping.launch.py`未使用原来fastlio的`launch`,而是跑的`fastlio_mapping`节点，查看fastlio的cmake文件发现这个节点对应的代码是`FAST_LIO/src/laserMapping.cpp`，同时他们调用的参数在`sentry_bringup/params/fast_lio_mapping_param.yaml`

这里展示`mapping.launch.py`中的相关代码

```python
config_path = os.path.join(
      get_package_share_directory('sentry_bringup'), 'params')
fast_lio_param = os.path.join(
      config_path, 'fast_lio_mapping_param.yaml')
  fast_lio_node = Node(
        package='fast_lio',
        executable='fastlio_mapping',
        parameters=[
          fast_lio_param
        ],
        output='screen',
        remappings=[('/Odometry','/state_estimation')]
    )
```

于是在这里我将川大的代码和官方代码复制给ai问差异，发现差异很大之后，放弃官方代码，询问ai这份代码中有没有做出什么旋转，于是在ai的帮助下，我定位到了参数文件（**这里需要特别注意，不同launch可能调用不一样的参数文件，需要的时候记得修改**）

于是我们打开`sentry_bringup/params/fast_lio_mapping_param.yaml`
找到下面这段

```yaml
  mapping:
            acc_cov: 0.1
            gyr_cov: 0.1
            b_acc_cov: 0.0001
            b_gyr_cov: 0.0001
            fov_degree:    360.0
            det_range:     57.0
            extrinsic_est_en:  false      # true: enable the online estimation of IMU-LiDAR extrinsic
            extrinsic_T: [ -0.011, -0.02329, 0.04412 ]
            extrinsic_R: [ 1., 0., 0.,
                            0., -1., 0.,
                            0., 0., -1.]
```

其中，最下面两个参数分别是extrinsic_T（平移矩阵）、 extrinsic_R（旋转矩阵），平移矩阵的参数是官方给出的imu与雷达之间的平移关系，而下面的旋转矩阵是川大修改之后的，代表旋转180°，只需要将旋转矩阵修改为单位阵就是原来的角度了

修改之后

```yaml
  mapping:
            acc_cov: 0.1
            gyr_cov: 0.1
            b_acc_cov: 0.0001
            b_gyr_cov: 0.0001
            fov_degree:    360.0
            det_range:     57.0
            extrinsic_est_en:  false      # true: enable the online estimation of IMU-LiDAR extrinsic
            extrinsic_T: [ -0.011, -0.02329, 0.04412 ]
            extrinsic_R: [ 1., 0., 0.,
                            0., 1., 0.,
                            0., 0., 1.]
```

---

# 点云融合

> 参考[在ROS2 humble中实现Livox mid-360双雷达合成点云](https://blog.csdn.net/whisper_ming/article/details/145174691?ops_request_misc=elastic_search_misc&request_id=b8e94bb604e8c4a9f37bebf85177d937&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-145174691-null-null.142^v102^pc_search_result_base2&utm_term=双雷达融合&spm=1018.2226.3001.4187)

