# 斜雷达的思路(重力对齐)

> 参考[倒装mid360雷达进行重力对齐](https://blog.csdn.net/weixin_65546874/article/details/152808848?ops_request_misc=elastic_search_misc&request_id=a793471a6f4466f278dda6b9a318e21b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-152808848-null-null.142^v102^pc_search_result_base2&utm_term=mid360倒置安装&spm=1018.2226.3001.4187)

在`FAST_LIO/src/IMU_Processing.hpp`中，将192、193行的

```c++
state_ikfom init_state = kf_state.get_x();
init_state.grav = S2(-mean_acc / mean_acc.norm() * G_m_s2);
```

改为

```c++
  // 让IMU测到的重力方向和世界坐标系的Z轴对齐
  // mean_acc是IMU静止时测到的加速度，实际上就是重力加速度的方向。
  // 比如正装IMU，mean_acc大约是[0, 0, 9.8]；倒装IMU大约是[0, 0, -9.8]
  /* modified by SanghyunPark - Start */
  // 计算一个旋转，把mean_acc转到世界Z轴
  Eigen::Quaterniond rotation = Eigen::Quaterniond::FromTwoVectors(mean_acc, Eigen::Vector3d::UnitZ());
  // 用这个旋转把IMU的坐标系转正
  mean_acc = rotation * mean_acc;
  mean_gyr = rotation * mean_gyr;
  state_ikfom init_state = kf_state.get_x();
  // 把这个旋转结果作为IMU的初始姿态
  init_state.rot = rotation;
  // 设置重力向量
  init_state.grav = S2(-mean_acc / mean_acc.norm() * G_m_s2);
```

---

# 将原本川大方案的倒置改回正置

总共需要修改两个地方

### 第一处

在于`cmd_chassis/src/rot_imu.cpp`(**省流：在回调函数中将对接收到的imu的`msg`的数据处理部分全部删除，只保留发布`msg`**)

将下面的代码

```c++
class IMURotateNode : public rclcpp::Node
{
public:
    IMURotateNode() : Node("imu_rotate_node", rclcpp::NodeOptions().use_intra_process_comms(true))
    {
        publisher_ = this->create_publisher<sensor_msgs::msg::Imu>("imu/data", 10);
        subscription_ = this->create_subscription<sensor_msgs::msg::Imu>(
            "livox/imu", 10, std::bind(&IMURotateNode::listener_callback, this, std::placeholders::_1));
    }

private:
    void listener_callback(const sensor_msgs::msg::Imu::UniquePtr msg)
    {
        // Create a quaternion for the rotation
        tf2::Quaternion rotation_quaternion;
        rotation_quaternion.setRPY(3.14159, 0, 0);  // 180 degrees in radians

        // Rotate the orientation of the IMU data
        msg->orientation.x = 0.0;
        msg->orientation.y = 0.0;
        msg->orientation.z = 0.0;
        msg->orientation.w = 1.0;

        msg->angular_velocity.z = -msg->angular_velocity.z;

        msg->linear_acceleration.y = -msg->linear_acceleration.y;
        msg->linear_acceleration.z = -msg->linear_acceleration.z;

        // Publish the rotated IMU data
        publisher_->publish(*msg);
    }

    rclcpp::Publisher<sensor_msgs::msg::Imu>::SharedPtr publisher_;
    rclcpp::Subscription<sensor_msgs::msg::Imu>::SharedPtr subscription_;
};
```

修改为
```c++
class IMURotateNode : public rclcpp::Node
{
public:
    IMURotateNode() : Node("imu_rotate_node", rclcpp::NodeOptions().use_intra_process_comms(true))
    {
        publisher_ = this->create_publisher<sensor_msgs::msg::Imu>("imu/data", 10);
        subscription_ = this->create_subscription<sensor_msgs::msg::Imu>(
            "livox/imu", 10, std::bind(&IMURotateNode::listener_callback, this, std::placeholders::_1));
    }

private:
    void listener_callback(const sensor_msgs::msg::Imu::UniquePtr msg)
    {
        publisher_->publish(*msg);
    }

    rclcpp::Publisher<sensor_msgs::msg::Imu>::SharedPtr publisher_;
    rclcpp::Subscription<sensor_msgs::msg::Imu>::SharedPtr subscription_;
};
```

### 第二处

> 一开始的思路是尝试直接将官方包替代川大的，后来发现川大的相较于官方的已经做出了相当大的修改，因此最终选择修改参数的方法

川大代码中`sentry_bringup`包中`mapping.launch.py`未使用原来fastlio的`launch`,而是跑的`fastlio_mapping`节点，查看fastlio的cmake文件发现这个节点对应的代码是`FAST_LIO/src/laserMapping.cpp`，同时他们调用的参数在`sentry_bringup/params/fast_lio_mapping_param.yaml`

这里展示`mapping.launch.py`中的相关代码

```python
config_path = os.path.join(
      get_package_share_directory('sentry_bringup'), 'params')
fast_lio_param = os.path.join(
      config_path, 'fast_lio_mapping_param.yaml')
  fast_lio_node = Node(
        package='fast_lio',
        executable='fastlio_mapping',
        parameters=[
          fast_lio_param
        ],
        output='screen',
        remappings=[('/Odometry','/state_estimation')]
    )
```

于是在这里我将川大的代码和官方代码复制给ai问差异，发现差异很大之后，放弃官方代码，询问ai这份代码中有没有做出什么旋转，于是在ai的帮助下，我定位到了参数文件（**这里需要特别注意，不同launch可能调用不一样的参数文件，需要的时候记得修改**）

于是我们打开`sentry_bringup/params/fast_lio_mapping_param.yaml`
找到下面这段

```yaml
  mapping:
            acc_cov: 0.1
            gyr_cov: 0.1
            b_acc_cov: 0.0001
            b_gyr_cov: 0.0001
            fov_degree:    360.0
            det_range:     57.0
            extrinsic_est_en:  false      # true: enable the online estimation of IMU-LiDAR extrinsic
            extrinsic_T: [ -0.011, -0.02329, 0.04412 ]
            extrinsic_R: [ 1., 0., 0.,
                            0., -1., 0.,
                            0., 0., -1.]
```

其中，最下面两个参数分别是extrinsic_T（平移矩阵）、 extrinsic_R（旋转矩阵），平移矩阵的参数是官方给出的imu与雷达之间的平移关系，而下面的旋转矩阵是川大修改之后的，代表旋转180°，只需要将旋转矩阵修改为单位阵就是原来的角度了

修改之后

```yaml
  mapping:
            acc_cov: 0.1
            gyr_cov: 0.1
            b_acc_cov: 0.0001
            b_gyr_cov: 0.0001
            fov_degree:    360.0
            det_range:     57.0
            extrinsic_est_en:  false      # true: enable the online estimation of IMU-LiDAR extrinsic
            extrinsic_T: [ -0.011, -0.02329, 0.04412 ]
            extrinsic_R: [ 1., 0., 0.,
                            0., 1., 0.,
                            0., 0., 1.]
```

---

# 点云融合

> 参考[在ROS2 humble中实现Livox mid-360双雷达合成点云](https://blog.csdn.net/whisper_ming/article/details/145174691?ops_request_misc=elastic_search_misc&request_id=b8e94bb604e8c4a9f37bebf85177d937&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-145174691-null-null.142^v102^pc_search_result_base2&utm_term=双雷达融合&spm=1018.2226.3001.4187)

创建包`implemention`

```bash
ros2 pkg create implemention --build-type ament_cmake --dependencies rclcpp
```



`implemention.cpp`

```c++
#include <rclcpp/rclcpp.hpp>
#include <livox_ros_driver2/msg/custom_msg.hpp>
#include <livox_ros_driver2/msg/custom_point.hpp>
#include <message_filters/subscriber.h>
#include <message_filters/sync_policies/approximate_time.h>
#include <message_filters/synchronizer.h>
#include <Eigen/Dense>
#include <Eigen/Geometry>

class MergeCloudCustomNode : public rclcpp::Node
{
public:
    MergeCloudCustomNode() : Node("merge_cloud_custom_node")
    {
        // 声明参数
        this->declare_parameter<std::string>("cloud1_topic", "/livox/lidar_192_168_1_118");
        this->declare_parameter<std::string>("cloud2_topic", "/livox/lidar_192_168_1_110");
        this->declare_parameter<std::string>("output_topic", "/livox/lidar");
        this->declare_parameter<std::string>("frame_id", "lidar");

        // Cloud1 变换参数（欧拉角单位：弧度，平移单位：米）
        this->declare_parameter<double>("cloud1_roll", 0.0);
        this->declare_parameter<double>("cloud1_pitch", 0.0);
        this->declare_parameter<double>("cloud1_yaw", 0.0);
        this->declare_parameter<double>("cloud1_tx", 0.0);
        this->declare_parameter<double>("cloud1_ty", 0.0);
        this->declare_parameter<double>("cloud1_tz", 0.0);

        // Cloud2 变换参数（欧拉角单位：弧度，平移单位：米）
        this->declare_parameter<double>("cloud2_roll", 1.57);
        this->declare_parameter<double>("cloud2_pitch", 0.0);
        this->declare_parameter<double>("cloud2_yaw", 0.0);
        this->declare_parameter<double>("cloud2_tx", 0.0);
        this->declare_parameter<double>("cloud2_ty", -0.24);
        this->declare_parameter<double>("cloud2_tz", -0.24);

        // 获取参数
        std::string cloud1_topic = this->get_parameter("cloud1_topic").as_string();
        std::string cloud2_topic = this->get_parameter("cloud2_topic").as_string();
        std::string output_topic = this->get_parameter("output_topic").as_string();
        frame_id_ = this->get_parameter("frame_id").as_string();

        // 获取变换参数
        roll1_ = this->get_parameter("cloud1_roll").as_double();
        pitch1_ = this->get_parameter("cloud1_pitch").as_double();
        yaw1_ = this->get_parameter("cloud1_yaw").as_double();
        tx1_ = this->get_parameter("cloud1_tx").as_double();
        ty1_ = this->get_parameter("cloud1_ty").as_double();
        tz1_ = this->get_parameter("cloud1_tz").as_double();

        roll2_ = this->get_parameter("cloud2_roll").as_double();
        pitch2_ = this->get_parameter("cloud2_pitch").as_double();
        yaw2_ = this->get_parameter("cloud2_yaw").as_double();
        tx2_ = this->get_parameter("cloud2_tx").as_double();
        ty2_ = this->get_parameter("cloud2_ty").as_double();
        tz2_ = this->get_parameter("cloud2_tz").as_double();

        // 计算变换矩阵
        computeTransformMatrix(transform1_, roll1_, pitch1_, yaw1_, tx1_, ty1_, tz1_);
        computeTransformMatrix(transform2_, roll2_, pitch2_, yaw2_, tx2_, ty2_, tz2_);

        // 订阅两个 Livox CustomMsg 话题
        cloud1_sub_.subscribe(this, cloud1_topic);
        cloud2_sub_.subscribe(this, cloud2_topic);

        // 使用 ApproximateTime 同步器
        sync_ = std::make_shared<message_filters::Synchronizer<SyncPolicy>>(
            SyncPolicy(10), cloud1_sub_, cloud2_sub_);
        sync_->registerCallback(
            std::bind(&MergeCloudCustomNode::syncCallback, this,
                      std::placeholders::_1, std::placeholders::_2));

        // 发布合并后的 CustomMsg 点云
        merged_cloud_pub_ = this->create_publisher<livox_ros_driver2::msg::CustomMsg>(
            output_topic, 10);

        RCLCPP_INFO(this->get_logger(), "Merge Cloud Custom Node initialized");
        RCLCPP_INFO(this->get_logger(), "Subscribing to: %s and %s",
                    cloud1_topic.c_str(), cloud2_topic.c_str());
        RCLCPP_INFO(this->get_logger(), "Publishing to: %s", output_topic.c_str());
    }

private:
    void syncCallback(
        const livox_ros_driver2::msg::CustomMsg::ConstSharedPtr &cloud1_msg,
        const livox_ros_driver2::msg::CustomMsg::ConstSharedPtr &cloud2_msg)
    {
        // 创建输出消息
        auto merged_msg = std::make_unique<livox_ros_driver2::msg::CustomMsg>();

        // 使用较早的时间戳作为基准时间
        uint64_t base_timebase = std::min(cloud1_msg->timebase, cloud2_msg->timebase);
        merged_msg->timebase = base_timebase;
        merged_msg->header.stamp = this->now();
        merged_msg->header.frame_id = frame_id_;
        merged_msg->lidar_id = 0; // 合并后使用统一的 lidar_id

        // 计算时间偏移量
        int64_t time_offset1 = static_cast<int64_t>(cloud1_msg->timebase - base_timebase);
        int64_t time_offset2 = static_cast<int64_t>(cloud2_msg->timebase - base_timebase);

        // 预留空间
        merged_msg->points.reserve(cloud1_msg->point_num + cloud2_msg->point_num);

        // 处理第一个点云
        for (const auto &point : cloud1_msg->points)
        {
            livox_ros_driver2::msg::CustomPoint transformed_point;
            transformPoint(point, transformed_point, transform1_);

            // 调整时间偏移
            transformed_point.offset_time = point.offset_time + time_offset1;

            merged_msg->points.push_back(transformed_point);
        }

        // 处理第二个点云
        for (const auto &point : cloud2_msg->points)
        {
            livox_ros_driver2::msg::CustomPoint transformed_point;
            transformPoint(point, transformed_point, transform2_);

            // 调整时间偏移
            transformed_point.offset_time = point.offset_time + time_offset2;

            merged_msg->points.push_back(transformed_point);
        }

        // 设置点云总数
        merged_msg->point_num = merged_msg->points.size();

        // 发布合并后的点云
        merged_cloud_pub_->publish(std::move(merged_msg));

        RCLCPP_DEBUG(this->get_logger(),
                     "Published merged cloud with %u points (cloud1: %u, cloud2: %u)",
                     merged_msg->point_num, cloud1_msg->point_num, cloud2_msg->point_num);
    }

    // 对单个点进行坐标变换
    void transformPoint(
        const livox_ros_driver2::msg::CustomPoint &point_in,
        livox_ros_driver2::msg::CustomPoint &point_out,
        const Eigen::Matrix4d &transform)
    {
        // 转换为齐次坐标
        Eigen::Vector4d point_in_vec(point_in.x, point_in.y, point_in.z, 1.0);

        // 应用变换
        Eigen::Vector4d point_out_vec = transform * point_in_vec;

        // 设置变换后的坐标
        point_out.x = static_cast<float>(point_out_vec(0));
        point_out.y = static_cast<float>(point_out_vec(1));
        point_out.z = static_cast<float>(point_out_vec(2));

        // 保持其他属性不变
        point_out.offset_time = point_in.offset_time;
        point_out.reflectivity = point_in.reflectivity;
        point_out.tag = point_in.tag;
        point_out.line = point_in.line;
    }

    // 计算变换矩阵（欧拉角 + 平移）
    void computeTransformMatrix(
        Eigen::Matrix4d &transform,
        double roll, double pitch, double yaw,
        double tx, double ty, double tz)
    {
        // 使用 ZYX 欧拉角顺序（yaw-pitch-roll）创建旋转矩阵
        Eigen::AngleAxisd rollAngle(roll, Eigen::Vector3d::UnitX());
        Eigen::AngleAxisd pitchAngle(pitch, Eigen::Vector3d::UnitY());
        Eigen::AngleAxisd yawAngle(yaw, Eigen::Vector3d::UnitZ());

        Eigen::Quaterniond q = yawAngle * pitchAngle * rollAngle;
        Eigen::Matrix3d rotationMatrix = q.toRotationMatrix();

        // 构建 4x4 变换矩阵
        transform = Eigen::Matrix4d::Identity();
        transform.block<3, 3>(0, 0) = rotationMatrix;
        transform(0, 3) = tx;
        transform(1, 3) = ty;
        transform(2, 3) = tz;
    }

    // 定义同步策略
    typedef message_filters::sync_policies::ApproximateTime<
        livox_ros_driver2::msg::CustomMsg, livox_ros_driver2::msg::CustomMsg>
        SyncPolicy;

    // 订阅器
    message_filters::Subscriber<livox_ros_driver2::msg::CustomMsg> cloud1_sub_;
    message_filters::Subscriber<livox_ros_driver2::msg::CustomMsg> cloud2_sub_;

    // 同步器
    std::shared_ptr<message_filters::Synchronizer<SyncPolicy>> sync_;

    // 发布器
    rclcpp::Publisher<livox_ros_driver2::msg::CustomMsg>::SharedPtr merged_cloud_pub_;

    // 变换矩阵
    Eigen::Matrix4d transform1_;
    Eigen::Matrix4d transform2_;

    // 变换参数
    double roll1_, pitch1_, yaw1_, tx1_, ty1_, tz1_;
    double roll2_, pitch2_, yaw2_, tx2_, ty2_, tz2_;

    // 坐标系名称
    std::string frame_id_;
};

int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<MergeCloudCustomNode>());
    rclcpp::shutdown();
    return 0;
}
```

修改`cmakelist`

```
cmake_minimum_required(VERSION 3.8)
project(implemention)

# 编译选项
if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# 依赖
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(livox_ros_driver2 REQUIRED)
find_package(message_filters REQUIRED)
find_package(Eigen3 REQUIRED)

# 可执行文件
add_executable(implemention
  src/implemention.cpp
)

# 头文件
target_include_directories(implemention PUBLIC
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
  $<INSTALL_INTERFACE:include>
  ${EIGEN3_INCLUDE_DIR}
)

# 依赖链接
ament_target_dependencies(
  implemention
  rclcpp
  livox_ros_driver2
  message_filters
)

# 安装
install(TARGETS
  implemention
  DESTINATION lib/${PROJECT_NAME}
)

ament_package()

```

修改`package.xml`

```xml
<?xml version="1.0"?>
<package format="3">
  <name>implemention</name>
  <version>0.0.1</version>
  <description>
    Merge multiple Livox CustomMsg point clouds with extrinsic calibration.
  </description>

  <maintainer email="you@example.com">your_name</maintainer>
  <license>MIT</license>

  <!-- 构建工具 -->
  <buildtool_depend>ament_cmake</buildtool_depend>

  <!-- 运行依赖 -->
  <depend>rclcpp</depend>
  <depend>livox_ros_driver2</depend>
  <depend>message_filters</depend>
  <depend>eigen</depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>

```





